{
  "Id": "838",
  "Title": "\u0022Mapping JSON Fields to Search Index: Best Practices and Examples\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdf\u0022jsonLines\u0022 } } } Map JSON fields to search fields{     \u0022article\u0022 : {         \u0022text\u0022 : \u0022A hopefully useful article explaining how to parse JSON blobs\u0022,         \u0022datePublished\u0022 : \u00222016-04-13\u0022         \u0022tags\u0022 : [ \u0022search\u0022, \u0022storage\u0022, \u0022howto\u0022 ]     Assume a search index with the following fields: text of type Edm.\r\nString, date of typeEdm.DateTimeOffset, and tags of type Collection(Edm.String). Notice the discrepancybetween \u0022datePublished\u0022 in the source and date field in the index. To map your JSONinto the desired shape, use the following field mappings:HTTPSource fields are specified using the JSON Pointer notation. You start with a forwardslash to refer to the root of your JSON document, then pick the desired property (atarbitrary level of nesting) by using forward slash-separated path.You can also refer to individual array elements by using a zero-based index.\r\nForexample, to pick the first element of the \u0022tags\u0022 array from the above example, use a fieldmapping like this:HTTPConfigure blob indexersDefine field mappingsIndexers overview    } } \u0022fieldMappings\u0022 : [     { \u0022sourceFieldName\u0022 : \u0022/article/text\u0022, \u0022targetFieldName\u0022 : \u0022text\u0022 },     { \u0022sourceFieldName\u0022 :\r\n\u0022/article/datePublished\u0022, \u0022targetFieldName\u0022 : \u0022date\u0022 },     { \u0022sourceFieldName\u0022 : \u0022/article/tags\u0022, \u0022targetFieldName\u0022 : \u0022tags\u0022 }     ] { \u0022sourceFieldName\u0022 : \u0022/article/tags/0\u0022, \u0022targetFieldName\u0022 : \u0022firstTag\u0022 } \uFF17 NoteIf \u0022sourceFieldName\u0022 refers to a property that doesn\u0027t exist in the JSON blob, thatmapping is skipped without an error. This behavior allows indexing to continue forJSON blobs that have a different schema (which is a common use case). Becausethere is no validation check, check the mappings carefully for typos so that youaren\u0027t losing documents for the wrong reason.\n"
}