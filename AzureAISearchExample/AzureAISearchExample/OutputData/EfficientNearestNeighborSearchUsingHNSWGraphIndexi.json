{
  "Id": "431",
  "Title": "\u0022Efficient Nearest Neighbor Search Using HNSW Graph Indexing\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdfGenerally, the input value within a query request isfed into the same machine learning model that generated embeddings in the vectorindex. The output is a vector in the same embedding space. Since similar vectors areclustered close together, finding matches is equivalent to finding the vectors that areclosest to the query vector, and returning the associated documents as the search result.\r\nFor example, if a query request is about hotels, the model maps the query into a vectorthat exists somewhere in the cluster of vectors representing documents about hotels.Identifying which vectors are the most similar to the query, based on a similarity metric,determines which documents are the most relevant.\r\nWhen vector fields are indexed for exhaustive KNN, the query executes against \u0022allneighbors\u0022. For fields indexed for HNSW, the search engine uses an HNSW graph tosearch over a subset of nodes within the vector index.The goal of indexing a new vector into an HNSW graph is to add it to the graphstructure in a manner that allows for efficient nearest neighbor search.\r\nThe followingsteps summarize the process:1. Initialization: Start with an empty HNSW graph, or the existing HNSW graph if it\u0027snot a new index.2. Entry point: This is the top-level of the hierarchical graph and serves as the startingpoint for indexing.When to use HNSWHow nearest neighbor search worksCreating the HNSW graph3. Adding to the graph: Different hierarchical levels represent different granularitiesof the graph, with higher levels being more global, and lower levels being moregranular. Each node in the graph represents a vector point.Each node is connected to up to m neighbors that are nearby. This is the mparameter.The number of data points that considered as candidate connections isgoverned by the efConstruction parameter. This dynamic list forms the set ofclosest points in the existing graph for the algorithm to consider. HigherefConstruction values result in more nodes being considered, which oftenleads to denser local neighborhoods for each vector.\n"
}