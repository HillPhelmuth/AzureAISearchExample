{
  "Id": "826",
  "Title": "\u0022Best Practices for Field Mapping in Azure Search Indexing\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdfjsonJSONWhen you create an indexer with delimitedText parsingMode, it might feel natural toset up a field-mapping function to the key field as follows:HTTPCustom field mapping for index key fieldrecordid, temperature, pressure, timestamp1, 100, 100,\u00222019-02-13T00:00:00Z\u0022 2, 33, 30,\u00222019-02-14T00:00:\r\n00Z\u0022 recordid, temperature, pressure, timestamp1, 1, 1,\u00222018-01-12T00:00:00Z\u0022 2, 120, 3,\u00222013-05-11T00:00:00Z\u0022 {    \u0022sourceFieldName\u0022 : \u0022recordid\u0022,    \u0022targetFieldName\u0022: \u0022id\u0022}However, this mapping won\u0027t result in four documents showing up in the index becausethe recordid field isn\u0027t unique across blobs.\r\nHence, we recommend you to make use ofthe implicit field mapping applied from the AzureSearch_DocumentKey property to thekey index field for \u0022one-to-many\u0022 parsing modes.If you do want to set up an explicit field mapping, make sure that the sourceField isdistinct for each individual entity across all blobs.\r\nAssuming the same index definition as the previous example and parsingMode is set tojsonLines without specifying any explicit field mappings so the mappings look like inthe first example, suppose your blob container has blobs with the following structure:Blob1.jsonJSONBlob2.jsonJSONNotice that each document contains the id field, which is defined as the key field in theindex. In such a case, even though a document-unique AzureSearch_DocumentKey will begenerated, it won\u0027t be used as the \u0022key\u0022 for the document. Rather, the value of the idfield will be mapped to the key field\uFF17 NoteThe approach used by AzureSearch_DocumentKey of ensuring uniqueness perextracted entity is subject to change and therefore you should not rely on it\u0027s valuefor your application\u0027s needs.\n"
}