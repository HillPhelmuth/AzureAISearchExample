{
  "Id": "1043",
  "Title": "\u0022Enriching Search Indexes with Azure REST API Field Mappings\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdfIf you need examples, run the wizard over your dataUse Create Indexer (REST) or Update Indexer (REST), any API version.This example adds entities and sentiment labels extracted from a blob\u0027s contentproperty to fields in a search index.JSONFor each output field mapping, set the location of the data in the enricheddocument tree (sourceFieldName), and the name of the field as referenced in theindex (targetFieldName).\r\nAssign any mapping functions that you require totransform the content of a field before it\u0027s stored in the index.source to see the rendered definition.REST APIsPUT https://[service name].search.windows.\r\nnet/indexers/myindexer?\r\napi-version=[api-version] Content-Type: application/json api-key: [admin key] {     \u0022name\u0022: \u0022myIndexer\u0022,     \u0022dataSourceName\u0022: \u0022myDataSource\u0022,     \u0022targetIndexName\u0022: \u0022myIndex\u0022,     \u0022skillsetName\u0022: \u0022myFirstSkillSet\u0022,     \u0022fieldMappings\u0022: [],     \u0022outputFieldMappings\u0022: [         {             \u0022sourceFieldName\u0022: \u0022/document/content/organizations/*/description\u0022,             \u0022targetFieldName\u0022: \u0022descriptions\u0022,             \u0022mappingFunction\u0022:\r\n{                 \u0022name\u0022: \u0022base64Decode\u0022             }         },         {             \u0022sourceFieldName\u0022: \u0022/document/content/organizations\u0022,             \u0022targetFieldName\u0022: \u0022orgNames\u0022         },         {             \u0022sourceFieldName\u0022: \u0022/document/content/sentiment\u0022,             \u0022targetFieldName\u0022: \u0022sentiment\u0022         }     ] } If your source data is composed of nested or hierarchical JSON, you can\u0027t use fieldmappings to set up the data paths.\r\nInstead, your search index must mirror the sourcedata structure for at each level for a full import.This section walks you through an import process that produces a one-to-one reflectionof a complex document on both the source and target sides. Next, it uses the samesource document to illustrate the retrieval and flattening of individual nodes into stringcollections.Here\u0027s an example of a document in Azure Cosmos DB with nested JSON:JSONIf you wanted to fully index the above source document, you\u0027d create an index definitionwhere the field names, levels, and types are reflected as a complex type.\n"
}