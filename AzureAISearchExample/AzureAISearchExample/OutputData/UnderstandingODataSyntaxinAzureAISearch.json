{
  "Id": "1641",
  "Title": "\u0022Understanding OData Syntax in Azure AI Search\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdf:= zero_to_fifty_ninefractional_seconds ::= integer_literaltime_zone ::= \u0027Z\u0027 | sign hour\u0027:\u0027minutesign ::= \u0027\u002B\u0027 | \u0027-\u0027/* In practice integer literals are limited in length to the precision ofthe corresponding EDM data type.\r\n*/integer_literal ::= sign? digit\u002Bfloat_literal ::=    sign? whole_part fractional_part? exponent?    | \u0027NaN\u0027    | \u0027-INF\u0027    | \u0027INF\u0027whole_part ::= integer_literalfractional_part ::= \u0027.\u0027integer_literalexponent ::= \u0027e\u0027 sign? integer_literalboolean_literal ::= \u0027true\u0027 | \u0027false\u0027To visually explore the OData language grammar supported by Azure AI Search, try theinteractive syntax diagram:/* Rules for functions */function_call ::=    geo_distance_call |    boolean_function_callgeo_distance_call ::=    \u0027geo.distance(\u0027 variable \u0027,\u0027 geo_point \u0027)\u0027    | \u0027geo.\r\ndistance(\u0027 geo_point \u0027,\u0027 variable \u0027)\u0027geo_point ::= \u0022geography\u0027POINT(\u0022 lon_lat \u0022)\u0027\u0022lon_lat ::= float_literal \u0027 \u0027 float_literalboolean_function_call ::=    geo_intersects_call |    search_in_call |    search_is_match_callgeo_intersects_call ::=    \u0027geo.intersects(\u0027 variable \u0027,\u0027 geo_polygon \u0027)\u0027/* You need at least four points to form a polygon, where the first andlast points are the same.\r\n*/geo_polygon ::=    \u0022geography\u0027POLYGON((\u0022 lon_lat \u0027,\u0027 lon_lat \u0027,\u0027 lon_lat \u0027,\u0027 lon_lat_list \u0022))\u0027\u0022lon_lat_list ::= lon_lat(\u0027,\u0027 lon_lat)*search_in_call ::=    \u0027search.in(\u0027 variable \u0027,\u0027 string_literal(\u0027,\u0027 string_literal)? \u0027)\u0027/* Note that it is illegal to call search.ismatch or search.ismatchscoringfrom inside a lambda expression.\r\n*/search_is_match_call ::=    \u0027search. ismatch\u0027(\u0027scoring\u0027)?\u0027(\u0027 search_is_match_parameters \u0027)\u0027search_is_match_parameters ::=    string_literal(\u0027,\u0027 string_literal(\u0027,\u0027 query_type \u0027,\u0027 search_mode)?)?query_type ::= \u0022\u0027full\u0027\u0022 | \u0022\u0027simple\u0027\u0022search_mode ::= \u0022\u0027any\u0027\u0022 | \u0022\u0027all\u0027\u0022Syntax diagramFilters in Azure AI SearchSearch Documents (Azure AI Search REST API)Lucene query syntaxSimple query syntax in Azure AI SearchOData syntax diagram for Azure AI SearchSee alsoSimple query syntax in Azure CognitiveSearchArticle\u202212/19/2022Azure Cognitive Search implements two Lucene-based query languages: Simple QueryParser and the Lucene Query Parser.\n"
}