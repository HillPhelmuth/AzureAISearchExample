{
  "Id": "1244",
  "Title": "\u0022Effective Pagination Techniques for Azure Search Queries\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdfReturn the first set of 15 matching documents plus a count of total matches: GET/indexes/\u003CINDEX-NAME\u003E/docs?search=\u003CQUERY STRING\u003E\u0026$top=15\u0026$skip=0\u0026$count=trueReturn the second set, skipping the first 15 to get the next 15: $top=15\u0026$skip=15.Repeat for the third set of 15: $top=15\u0026$skip=30The results of paginated queries aren\u0027t guaranteed to be stable if the underlying index ischanging.\r\nPaging changes the value of $skip for each page, but each query isindependent and operates on the current view of the data as it exists in the index atquery time (in other words, there\u0027s no caching or snapshot of results, such as thosefound in a general purpose database).Following is an example of how you might get duplicates.\r\nAssume an index with fourdocuments:\uEA80 TipTo check indexing operations, you can confirm whether the index contains theexpected number of documents by adding $count=true on an empty searchsearch=* query. The result is the full count of documents in your index.When testing query syntax, $count=true can quickly tell you whether yourmodifications are returning greater or fewer results, which can be useful feedback.\r\nPaging resultsJSONNow assume you want results returned two at a time, ordered by rating. You wouldexecute this query to get the first page of results: $top=2\u0026$skip=0\u0026$orderby=rating desc,producing the following results:JSONOn the service, assume a fifth document is added to the index in between query calls: {\u0022id\u0022: \u00225\u0022, \u0022rating\u0022: 4 }. Shortly thereafter, you execute a query to fetch the secondpage: $top=2\u0026$skip=2\u0026$orderby=rating desc, and get these results:JSONNotice that document 2 is fetched twice. This is because the new document 5 has agreater value for rating, so it sorts before document 2 and lands on the first page.\n"
}