{
  "Id": "825",
  "Title": "\u0022Data Parsing and Field Mapping in Azure Search\u0022",
  "Text": "C:\\Users\\adamh\\Downloads\\azure-search.pdfHTTPExample{ \u0022temperature\u0022: 100, \u0022pressure\u0022: 100, \u0022timestamp\u0022: \u00222020-02-13T00:00:00Z\u0022 }{ \u0022temperature\u0022 : 33, \u0022pressure\u0022 : 30, \u0022timestamp\u0022: \u00222020-02-14T00:00:00Z\u0022 }{ \u0022temperature\u0022: 1, \u0022pressure\u0022: 1, \u0022timestamp\u0022: \u00222019-01-12T00:00:00Z\u0022 }{ \u0022temperature\u0022 : 120, \u0022pressure\u0022 : 3, \u0022timestamp\u0022:\r\n\u00222017-05-11T00:00:00Z\u0022 }{    \u0022sourceFieldName\u0022 : \u0022AzureSearch_DocumentKey\u0022,    \u0022targetFieldName\u0022: \u0022id\u0022,    \u0022mappingFunction\u0022: { \u0022name\u0022 : \u0022base64Encode\u0022 }}This setup will result in disambiguated document keys, similar to the followingillustration (base64-encoded ID shortened for brevity).\r\nIDtemperaturepressuretimestampaHR0 ... YjEuanNvbjsx1001002020-02-13T00:00:00ZaHR0 ... YjEuanNvbjsy33302020-02-14T00:00:00ZaHR0 ... YjIuanNvbjsx112019-01-12T00:00:00ZaHR0 ...\r\nYjIuanNvbjsy12032017-05-11T00:00:00ZAssuming the same index definition as the previous example, suppose your blobcontainer has blobs with the following structure:Blob1.jsonJSONBlob2. jsonJSONWhen you create an indexer with delimitedText parsingMode, it might feel natural toset up a field-mapping function to the key field as follows:HTTPCustom field mapping for index key fieldrecordid, temperature, pressure, timestamp1, 100, 100,\u00222019-02-13T00:00:00Z\u0022 2, 33, 30,\u00222019-02-14T00:00:\n"
}